/*
 * main.c
 *
 *  Created on: Dec 18, 2020
 *      Author: belyaev
 */
//*******************************************************************************************
//*******************************************************************************************

#include "main.h"

//*******************************************************************************************
//*******************************************************************************************
void IncrementOnEachPass(uint32_t *var, uint16_t event){

		   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) (*var)++;
}
//************************************************************
void DecrementOnEachPass(uint32_t *var, uint16_t event){

		   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) (*var)--;
}
//************************************************************
void Led_Blink(void){

//	if(Blink(INTERVAL_50_mS)) Led_PC13_On();
//	else					  Led_PC13_Off();
}
//************************************************************
uint8_t tic(uint16_t event){

	  	   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) return 1;
	else 		return 0;
}
//*******************************************************************************************
//*******************************************************************************************
//Работа с энкодером AMM3617.
//Энкодер выдает 17-ти битный код Грея.

#define ENCODER_STEP (36000.0 / (65535))//Шаг энкодера. Энкодер 17 битный.
																				//При выравнивании Старший бит теряется => код получается 16 бит.

//************************************************************
//************************************************************
//Преобразование кода Грея в бинарный код. Вар1.
uint32_t GrayToBin(uint32_t grayCode){

	uint32_t bin;
    //--------------------------
    for(bin = 0; grayCode; grayCode >>= 1)
    {
      bin ^= grayCode;
    }
    return bin;
}
//------------------------------------------------------------
//Преобразование кода Грея в бинарный код. Вар2.
uint32_t GrayToBin2(uint32_t grayCode){

	grayCode ^= (grayCode >> 1);
	grayCode ^= (grayCode >> 2);
	grayCode ^= (grayCode >> 4);
	grayCode ^= (grayCode >> 8);
	grayCode ^= (grayCode >> 16);
	return grayCode;
}
//------------------------------------------------------------
//Получение значение поворота энкодера в от 0 до 36000.
uint16_t Encoder_GetAngle(void){

	//Чтение и выравнивание данных из энкодера. Уменьшение разрешения энкодера до 16 бит.
	uint32_t encoderVal = ((Spi1Rx3Byte() >> 7) & 0x0000FFFF);
	//Преобразование кода Грея в двоичный код.
	//encoderVal = GrayToBin(encoderVal);
	encoderVal = GrayToBin2(encoderVal);

	return (uint16_t)(encoderVal * ENCODER_STEP);
}
//*******************************************************************************************
//*******************************************************************************************
int main(void){


	//--------------------------
	//Drivers.
	Sys_Init();
	Gpio_Init();
	SysTick_Init();
	Adc_Init();
	__enable_irq();
	//***********************************************
	TIM1_InitForPWM(1024);
	//TIM3_InitForPWM();//TIM3 генерирует ШИМ для трех каналов.
	TIM4_Init();        //TIM4 настривается для периодической генерации прерывания.


	//Настройка DMA для работы с таймером.
	//DMA1_ChX_Init(DMA1_Channel4, pwm_value, (sizeof(pwm_value) / sizeof(pwm_value[0])) );
	//***********************************************
	//Инициализация дисплея.
	I2C_Init(I2C1);
	SSD1306_Init(I2C1);

	Lcd_String(1, 1);
	Lcd_Print("Motor Driver L6234");
	Lcd_Update();
	//***********************************************
	//Инициализация SPI для работы с энкодером.
	Spi1Init();

	//***********************************************
	//Определение смешения в каналах измерения тока фаз мотора.
	uint16_t Ia_AdcOffset = 0;
	for(uint8_t i=0; i <= 16; i++)
		{
			Ia_AdcOffset = Average(Adc_GetMeas(Ia_ADC_CH), 16);
		}
	//***********************************************
	//__disable_irq();
	msDelay(500);
	//************************************************************************************
	while(1)
		{
			msDelay(5);
			//***********************************************
			//Мигание светодиодами.
			Led_Blink();
			//***********************************************
			//Чтение данных из энкодера.

			uint16_t Degrees = Encoder_GetAngle();

			Lcd_String(1, 4);
			Lcd_Print("EnCode=");
			Lcd_u32ToHex(Degrees);

			Lcd_String(1, 5);
			Lcd_Print("Degrees=");
			Lcd_BinToDec((uint16_t)(Degrees/100), 3, LCD_CHAR_SIZE_NORM);
			Lcd_Chr('.');
			Lcd_BinToDec((uint16_t)(Degrees%100), 2, LCD_CHAR_SIZE_NORM);
			//***********************************************
			//Измерение тока фаз двигателя.

			uint16_t Ia = Average(Adc_GetMeas(Ia_ADC_CH), 16) - Ia_AdcOffset;

			Lcd_String(1, 6);
			Lcd_Print("Ia=");
			Lcd_BinToDec(Ia, 5, LCD_CHAR_SIZE_NORM);

			Lcd_Update();
			//***********************************************
			//Управление двигателем.


			//***********************************************
			/* Sleep */
			//__WFI();
		}
	//************************************************************************************
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание каждую милисекунду.
void SysTick_Handler(void){

//	static uint16_t msCountForDS18B20 = 0;
//	//--------------------------
//	//Отсчет таймаута для датчика температуры.
//	if(++msCountForDS18B20 >= 1000)
//		{
//			msCountForDS18B20 = 0;
//			FlagsStr.DS18B20  = 1;
//		}
	//--------------------------
	msDelay_Loop();
	Blink_Loop();
	Encoder()->Loop();
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание TIM4.
void TIM4_IRQHandler(void){

	uint16_t pwm1, pwm2, pwm3;
	//--------------------------
	TIM4->SR &= ~TIM_SR_UIF;//Сброс флага прерывания.
	//--------------------------
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание TIM1.
void TIM1_UP_IRQHandler(void){

	//--------------------------
	TIM1->SR &= ~TIM_SR_UIF;//Сброс флага прерывания.
	//--------------------------
	Led_PC13_Toggel();
}
//*******************************************************************************************
//*******************************************************************************************































