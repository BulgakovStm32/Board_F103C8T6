/*
 * main.c
 *
 *  Created on: Dec 18, 2020
 *      Author: belyaev
 */
//*******************************************************************************************
//*******************************************************************************************
#include "main.h"



//*******************************************************************************************
//*******************************************************************************************
//Переменные
//static uint32_t PWRval        = 0;
static uint16_t sinTableIndex = 0;

//*******************************************************************************************
//*******************************************************************************************
void IncrementOnEachPass(uint32_t *var, uint16_t event){

		   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) (*var)++;
}
//************************************************************
void DecrementOnEachPass(uint32_t *var, uint16_t event){

		   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) (*var)--;
}
//************************************************************
void Led_Blink(void){

	if(Blink(INTERVAL_50_mS)) Led_PC13_On();
	else					  Led_PC13_Off();
}
//************************************************************
uint8_t tic(uint16_t event){

	  	   uint16_t riseReg  = 0;
	static uint16_t oldState = 0;
	//--------------------------
	riseReg  = (oldState ^ event) & event;
	oldState = event;
	if(riseReg) return 1;
	else 		return 0;
}
//*******************************************************************************************
//*******************************************************************************************
#define EN1	1
#define EN2	2
#define EN3	3

#define MOTOR_DELAY 4
#define EN_ON	    860 //820 - 860 //в этом диапазоне ШИМ мотор работает тихо
#define EN_OFF      0   //10
//************************************************************
// Sin table
#define PMSM_SINTABLESIZE	192

#pragma pack(push, 1)//размер выравнивания в 1 байт
static const uint8_t PMSM_SINTABLE [PMSM_SINTABLESIZE][3] =
{
	{0,       0,      221},
	{8,       0,      225},
	{17,      0,      229},
	{25,      0,      232},
	{33,      0,      236},
	{42,      0,      239},
	{50,      0,      241},
	{58,      0,      244},
	{66,      0,      246},
	{74,      0,      248},
	{82,      0,      250},
	{90,      0,      252},
	{98,      0,      253},
	{105,     0,      254},
	{113,     0,      254},
	{120,     0,      255},
	{128,     0,      255},
	{135,     0,      255},
	{142,     0,      254},
	{149,     0,      254},
	{155,     0,      253},
	{162,     0,      252},
	{168,     0,      250},
	{174,     0,      248},
	{180,     0,      246},
	{186,     0,      244},
	{192,     0,      241},
	{197,     0,      239},
	{202,     0,      236},
	{207,     0,      232},
	{212,     0,      229},
	{217,     0,      225},
	{221,     0,      221},
	{225,     0,      217},
	{229,     0,      212},
	{232,     0,      207},
	{236,     0,      202},
	{239,     0,      197},
	{241,     0,      192},
	{244,     0,      186},
	{246,     0,      180},
	{248,     0,      174},
	{250,     0,      168},
	{252,     0,      162},
	{253,     0,      155},
	{254,     0,      149},
	{254,     0,      142},
	{255,     0,      135},
	{255,     0,      127},
	{255,     0,      120},
	{254,     0,      113},
	{254,     0,      105},
	{253,     0,      98},
	{252,     0,      90},
	{250,     0,      82},
	{248,     0,      74},
	{246,     0,      66},
	{244,     0,      58},
	{241,     0,      50},
	{239,     0,      42},
	{236,     0,      33},
	{232,     0,      25},
	{229,     0,      17},
	{225,     0,      8},
	{221,     0,      0},
	{225,     8,      0},
	{229,     17,     0},
	{232,     25,     0},
	{236,     33,     0},
	{239,     42,     0},
	{241,     50,     0},
	{244,     58,     0},
	{246,     66,     0},
	{248,     74,     0},
	{250,     82,     0},
	{252,     90,     0},
	{253,     98,     0},
	{254,     105,    0},
	{254,     113,    0},
	{255,     120,    0},
	{255,     127,    0},
	{255,     135,    0},
	{254,     142,    0},
	{254,     149,    0},
	{253,     155,    0},
	{252,     162,    0},
	{250,     168,    0},
	{248,     174,    0},
	{246,     180,    0},
	{244,     186,    0},
	{241,     192,    0},
	{239,     197,    0},
	{236,     202,    0},
	{232,     207,    0},
	{229,     212,    0},
	{225,     217,    0},
	{221,     221,    0},
	{217,     225,    0},
	{212,     229,    0},
	{207,     232,    0},
	{202,     236,    0},
	{197,     239,    0},
	{192,     241,    0},
	{186,     244,    0},
	{180,     246,    0},
	{174,     248,    0},
	{168,     250,    0},
	{162,     252,    0},
	{155,     253,    0},
	{149,     254,    0},
	{142,     254,    0},
	{135,     255,    0},
	{128,     255,    0},
	{120,     255,    0},
	{113,     254,    0},
	{105,     254,    0},
	{98,      253,    0},
	{90,      252,    0},
	{82,      250,    0},
	{74,      248,    0},
	{66,      246,    0},
	{58,      244,    0},
	{50,      241,    0},
	{42,      239,    0},
	{33,      236,    0},
	{25,      232,    0},
	{17,      229,    0},
	{8,       225,    0},
	{0,       221,    0},
	{0,       225,    8},
	{0,       229,    17},
	{0,       232,    25},
	{0,       236,    33},
	{0,       239,    42},
	{0,       241,    50},
	{0,       244,    58},
	{0,       246,    66},
	{0,       248,    74},
	{0,       250,    82},
	{0,       252,    90},
	{0,       253,    98},
	{0,       254,    105},
	{0,       254,    113},
	{0,       255,    120},
	{0,       255,    128},
	{0,       255,    135},
	{0,       254,    142},
	{0,       254,    149},
	{0,       253,    155},
	{0,       252,    162},
	{0,       250,    168},
	{0,       248,    174},
	{0,       246,    180},
	{0,       244,    186},
	{0,       241,    192},
	{0,       239,    197},
	{0,       236,    202},
	{0,       232,    207},
	{0,       229,    212},
	{0,       225,    217},
	{0,       221,    221},
	{0,       217,    225},
	{0,       212,    229},
	{0,       207,    232},
	{0,       202,    236},
	{0,       197,    239},
	{0,       192,    241},
	{0,       186,    244},
	{0,       180,    246},
	{0,       174,    248},
	{0,       168,    250},
	{0,       162,    252},
	{0,       155,    253},
	{0,       149,    254},
	{0,       142,    254},
	{0,       135,    255},
	{0,       128,    255},
	{0,       120,    255},
	{0,       113,    254},
	{0,       105,    254},
	{0,       98,     253},
	{0,       90,     252},
	{0,       82,     250},
	{0,       74,     248},
	{0,       66,     246},
	{0,       58,     244},
	{0,       50,     241},
	{0,       42,     239},
	{0,       33,     236},
	{0,       25,     232},
	{0,       17,     229},
	{0,       8,      225}
};
#pragma pack(pop)//вернули предыдущую настройку.
//************************************************************
//************************************************************
//Комутация обмоток двигателя ногодрыгом.
void BLDC_Commutation(void){

	//Фаза 1.
	MOTOR_EN1_On();
	MOTOR_IN1_On();

	MOTOR_EN2_On();
	MOTOR_IN2_Off();

	MOTOR_EN3_Off();

	msDelay(MOTOR_DELAY);

	//Фаза 2.
	MOTOR_EN2_Off();

	MOTOR_EN3_On();
	MOTOR_IN3_Off();

	msDelay(MOTOR_DELAY);

	//Фаза 3.
	MOTOR_EN1_Off();

	MOTOR_EN2_On();
	MOTOR_IN2_On();

	msDelay(MOTOR_DELAY);

	//Фаза 4.
	MOTOR_EN1_On();
	MOTOR_IN1_Off();

	MOTOR_EN3_Off();

	msDelay(MOTOR_DELAY);

	//Фаза 5.
	MOTOR_EN2_Off();

	MOTOR_EN3_On();
	MOTOR_IN3_On();

	msDelay(MOTOR_DELAY);

	//Фаза 6.
	MOTOR_EN1_Off();

	MOTOR_EN2_On();
	MOTOR_IN2_Off();

	msDelay(MOTOR_DELAY);
}
//************************************************************
void PWM_SetVal(uint8_t output, uint32_t pwmVal){

	if(output == EN1) TIM3->CCR1 = pwmVal;
	if(output == EN2) TIM3->CCR2 = pwmVal;
	if(output == EN3) TIM3->CCR3 = pwmVal;
}
//************************************************************
// Set PWM (same for all phases)
void PMSM_SetPWM(uint16_t PWM){

	TIM3->CCR1 = PWM;
	TIM3->CCR2 = PWM;
	TIM3->CCR3 = PWM;
}
//************************************************************
// Set PWM
void PMSM_SetPWM_UVW(uint16_t PWM1, uint16_t PWM2, uint16_t PWM3){

	TIM3->CCR1 = PWM1;
	TIM3->CCR2 = PWM2;
	TIM3->CCR3 = PWM3;
}
//************************************************************
//В этой реализации управления ШИМ подается на линии EN.
//На каждую линию EN свой согнал ШИМ.
void BLDC_PWMCommutation(void){

	static uint8_t phaseCounter = 0;
	//--------------------------
	phaseCounter++;
	switch(phaseCounter-1){
		//--------------
		case(0):
		//Фаза 1.
		MOTOR_IN1_On();
		PWM_SetVal(EN1, EN_ON);

		MOTOR_IN2_Off();
		PWM_SetVal(EN2, EN_ON);

		PWM_SetVal(EN3, EN_OFF);
		break;
		//--------------
		case(1):
		//Фаза 2.
		PWM_SetVal(EN2, EN_OFF);

		MOTOR_IN3_Off();
		PWM_SetVal(EN3, EN_ON);
		break;
		//--------------
		case(2):
		//Фаза 3.
		PWM_SetVal(EN1, EN_OFF);

		MOTOR_IN2_On();
		PWM_SetVal(EN2, EN_ON);
		break;
		//--------------
		case(3):
		//Фаза 4.
		MOTOR_IN1_Off();
		PWM_SetVal(EN1, EN_ON);

		PWM_SetVal(EN3, EN_OFF);
		break;
		//--------------
		case(4):
		//Фаза 5.
		PWM_SetVal(EN2, EN_OFF);

		MOTOR_IN3_On();
		PWM_SetVal(EN3, EN_ON);
		break;
		//--------------
		case(5):
		//Фаза 6.
		PWM_SetVal(EN1, EN_OFF);

		MOTOR_IN2_Off();
		PWM_SetVal(EN2, EN_ON);

		phaseCounter = 0;
		break;
		//--------------
		default:
		break;
		//--------------
	}


}
//************************************************************
void BLDC_PWMCommutation_rev2(void){

	static uint8_t phaseCounter = 0;
	//--------------------------
	phaseCounter++;
	switch(phaseCounter-1){
		//--------------
		case(0):
		//Фаза 1.

		break;
		//--------------
		case(1):
		//Фаза 2.

		break;
		//--------------
		case(2):
		//Фаза 3.

		break;
		//--------------
		case(3):
		//Фаза 4.

		break;
		//--------------
		case(4):
		//Фаза 5.

		break;
		//--------------
		case(5):
		//Фаза 6.


		phaseCounter = 0;
		break;
		//--------------
		default:
		break;
		//--------------
	}
	//--------------------------
}
//*******************************************************************************************
//*******************************************************************************************
//This text copied from site Блог им. Catethysis https://catethysis.ru
//Read more: STM32: генератор синусоидального сигнала на TIM и DMA https://catethysis.ru/osnovnaya/stm32-tim-dma-pwm-sin

#define CPU_Freq 72000000 // частота ядра микроконтроллера
#define PWM_Freq 20000    // частота модуляции
#define MOD_Freq 50       // частота переменного тока

#define STEPS  		(PWM_Freq/MOD_Freq/2)//
#define PRECISION 	(CPU_Freq/PWM_Freq/2)
#define PI  		 3.1415926535
//************************************************************
//************************************************************

static uint16_t sin_arr[STEPS];
//************************************************************
//************************************************************
void FillSinTable(void){

	for(int i = 0; i < STEPS; i++)
		{
			sin_arr[i] = (uint16_t)(fabs(PRECISION * sin((i + 2) * PI/STEPS)));
		}
}
//*******************************************************************************************
//*******************************************************************************************

int main(void){


	//--------------------------
	//Drivers.
	Sys_Init();
	Gpio_Init();
	SysTick_Init();
	__enable_irq();
	//***********************************************
	TIM1_InitForPWM();
	//TIM3_InitForPWM();//TIM3 генерирует ШИМ для трех каналов.
	TIM4_Init();      //TIM4 настривается для периодической генерации прерывания.

	//Заполнение таблицы сиинуса.
	FillSinTable();

	//__disable_irq();
	msDelay(500);
	//************************************************************************************
	while(1)
		{
			//msDelay(10);
			//***********************************************
			//Мигание светодиодами.
			Led_Blink();
			//***********************************************
			//Управление двигателем.
			//BLDC_Commutation();   //Управление ногодрыгом. - Работает!!!
			//BLDC_PWMCommutation();//Управление ногодрыгом + ШИМ - Работает!!!
			//msDelay(MOTOR_DELAY);

//			msDelay(5000);
//			TIM4->CR1 &= ~TIM_CR1_CEN;  //Counter disable
//
//			msDelay(4000);
//			volatile uint32_t ARRval = 800;
//			TIM4->ARR = (ARRval - 1);
//			TIM4->CR1 = TIM_CR1_CEN;  //Counter enable
			//***********************************************
			/* Sleep */
			//__WFI();
		}
	//************************************************************************************
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание каждую милисекунду.
void SysTick_Handler(void){

//	static uint16_t msCountForDS18B20 = 0;
//	//--------------------------
//	//Отсчет таймаута для датчика температуры.
//	if(++msCountForDS18B20 >= 1000)
//		{
//			msCountForDS18B20 = 0;
//			FlagsStr.DS18B20  = 1;
//		}
	//--------------------------
	msDelay_Loop();
	Blink_Loop();
	Encoder()->Loop();
}
//*******************************************************************************************
//*******************************************************************************************
#define PMSM_PWM 650 //Коэфф-т заполнения от 0 до 1000



//Прерывание TIM4.
void TIM4_IRQHandler(void){

	uint16_t pwm1, pwm2, pwm3;
	//--------------------------
	TIM4->SR &= ~TIM_SR_UIF;//Сброс флага прерывания.
	//--------------------------
	//Генерация синуса
	static uint16_t sinIndex = 0;

	TIM1->CCR1 = sin_arr[sinIndex];

	// Increment position in sine table
	sinIndex++;
	if(sinIndex > STEPS-1) sinIndex = 0;

	//--------------------------
//	//BLDC_PWMCommutation();//Упраление ногодрыгом + ШИМ - Работает!!!
//
//	//Установка скорости вращения производится изменением частоты срабатывания
//	//таймера TIM4
//
//	// Calculate PWM for 3-phase
//	pwm1 = (uint16_t)((uint32_t)(PMSM_PWM * PMSM_SINTABLE[sinTableIndex][0]) / 255);
//	pwm2 = (uint16_t)((uint32_t)(PMSM_PWM * PMSM_SINTABLE[sinTableIndex][1]) / 255);
//	pwm3 = (uint16_t)((uint32_t)(PMSM_PWM * PMSM_SINTABLE[sinTableIndex][2]) / 255);
//
//	//Set PWM
//	TIM1->CCR1 = pwm1;
//	TIM1->CCR2 = pwm2;
//	TIM1->CCR3 = pwm3;
//	// Increment position in sine table
//	sinTableIndex++;
//	if(sinTableIndex > PMSM_SINTABLESIZE-1) sinTableIndex = 0;
	//--------------------------
}
//*******************************************************************************************
//*******************************************************************************************































