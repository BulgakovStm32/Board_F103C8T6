/*
 * main.c
 *
 *  Created on: Dec 18, 2020
 *      Author: belyaev
 */
//*******************************************************************************************
//*******************************************************************************************

#include "main.h"

//*******************************************************************************************
//*******************************************************************************************

volatile uint32_t sysTick   = 0;
volatile uint32_t uSecTick  = 0;

volatile float Angle      = 0.0;
volatile float oldAngle   = 0.0;
volatile float deltaAngle = 0.0;

volatile uint8_t  txBuf[64] = {0,};

//*******************************************************************************************
//*******************************************************************************************
void Led_Blink(void){

	if(Blink(INTERVAL_50_mS)) Led_PC13_On();
	else					  Led_PC13_Off();
//	Led_PC13_Toggel();
}
//*******************************************************************************************
//*******************************************************************************************
//Работа с энкодером AMM3617.Энкодер выдает 17-тибитный код Грея.
#define ENCODER_STEP (360000.0 / 131072)//Шаг энкодера. Энкодер 17 битный.
									    //При выравнивании Старший бит теряется => код получается 16 бит.

#define ENCODER_TIMEOUT 	(40 / 2)			      //деление на 2 так как uSecTick = 2 мкСек.
#define ENCODER_NUM_STEP 	131072 					  //количество шагов энкодера
#define ENCODER_QUANT  		(360.0 / ENCODER_NUM_STEP)//количество градусов в одном наге энкодера.

#define QUANT_FOR_100mS ((60 * 10 * 1000) / 360.0)
//************************************************************
//************************************************************
//Преобразование кода Грея в бинарный код.
uint32_t GrayToBin(uint32_t grayCode){

	grayCode ^= grayCode >> 1;
	grayCode ^= grayCode >> 2;
	grayCode ^= grayCode >> 4;
	grayCode ^= grayCode >> 8;
	grayCode ^= grayCode >> 16;
	return grayCode;
}
//------------------------------------------------------------
//Получение значение поворота энкодера.
uint32_t Encoder_GetTicks(void){

	//Чтение и выравнивание данных из энкодера.
	uint32_t encoderVal = (Spi1Rx3Byte() >> 6) & 0x0001FFFF; //Разрешения энкодера 17 бит.
	return GrayToBin(encoderVal);                            //Преобразование кода Грея в двоичный код.
}
//*******************************************************************************************
//*******************************************************************************************
void BinToDec(uint32_t var, uint8_t* buf){

	*(buf+0) = (uint8_t)(var / 100000) + '0';
	var %= 100000;

	*(buf+1) = (uint8_t)(var / 10000) + '0';
	var %= 10000;

	*(buf+2) = (uint8_t)(var / 1000) + '0';
	var %= 1000;

	*(buf+3) = ',';

	*(buf+4) = (uint8_t)(var / 100) + '0';
	var %= 100;

	*(buf+5) = (uint8_t)(var / 10) + '0';
	*(buf+6) = (uint8_t)(var % 10) + '0';
}
//*******************************************************************************************
//*******************************************************************************************
int main(void){

	uint32_t olduSecTicks = 0;
	volatile uint32_t encoderTicks = 0;
	//***********************************************
	Sys_Init();
	Gpio_Init();
	SysTick_Init();
	TIM4_Init();          //TIM4 настривается для периодической генерации прерывания.
	Spi1Init();           //Инициализация SPI для работы с энкодером.
	Uart1Init(USART1_BRR);

	__enable_irq();
	//************************************************************************************
	while(1)
		{
			//***********************************************
			//Мигание светодиодами.
			//Led_Blink();
			//--------------------------
			//Чтение данных из энкодера.
			if((uSecTick - olduSecTicks) >= ENCODER_TIMEOUT)
				{
				 	olduSecTicks = uSecTick;
				 	//Led_PC13_Toggel(); //Для отладки.
				 	//Led_PC13_On();

				 	__disable_irq();
				 	encoderTicks = Encoder_GetTicks();
					__enable_irq();
					//Преобразование в код Грея двух младших разрядов.
					unsigned q = (encoderTicks >> 2) & 3u;//Разрядность энкодера 8192
					  	 if (q == 2) q = 3;
					else if (q == 3) q = 2;
					//Ногодрыг
					((q >> 1u) & 1u) ? EncAOn() : EncAOff();
					 (q &  1u) ?       EncBOn() : EncBOff();

					 //Led_PC13_Off();
				}
			//--------------------------
			Angle      = ENCODER_QUANT * encoderTicks;//расчет угла поворота вала энкодера.
 			deltaAngle = fabs(Angle - oldAngle);      //приращение угла


			//--------------------------
			//Передача данных. каждые 250мСек.
//			if(sysTick - oldSysTick >= 250)
//				{
//					uint32_t temp = encoderTicks;// * ENCODER_STEP;
//					//uint32_t temp = Encoder_GetTicks() * ENCODER_STEP;
//					BinToDec(temp, txBuf);
//					txBuf[6] = '\r';
//					DMA1Ch4StartTx(txBuf, 7);
//
//					oldSysTick = sysTick;
//				}
			//***********************************************
			/* Sleep */
			//__WFI();
		}
	//************************************************************************************
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание каждую милисекунду.
void SysTick_Handler(void){

	static uint32_t mSecCount = 0;
	//--------------------------
	//sysTick++;
	//msDelay_Loop();
	//Blink_Loop();
	//Encoder()->Loop();
	//--------------------------
	if(++mSecCount >= 100)
		{
			//Led_PC13_On();
			mSecCount = 0;

			float rpm = deltaAngle * QUANT_FOR_100mS;
			oldAngle  = Angle;

			//Есть предполежения что на диске энкодера есть царапина,
			//из-за которой перодически приходит неправильное значение.
			//Это значение при расчете дает скорость в 592.ххх rpm.
			//Это проверка отсекает это ложное значение скорсти. Это костыль!!!! Но работает.
			if((uint32_t)rpm < 100000)
				{
					BinToDec((uint32_t)rpm, txBuf);
					txBuf[7] = '\r';
					DMA1Ch4StartTx(txBuf, 8);
				}
			//Led_PC13_Off();
		}
	//--------------------------
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание TIM4. Каждые 2 микросекунды.
void TIM4_IRQHandler(void){

	//--------------------------
	TIM4->SR &= ~TIM_SR_UIF;//Сброс флага прерывания.
	//--------------------------
	uSecTick++;
	//Led_PC13_Toggel();
}
//*******************************************************************************************
//*******************************************************************************************
//Прерывание TIM1.
void TIM1_UP_IRQHandler(void){

	//--------------------------
	TIM1->SR &= ~TIM_SR_UIF;//Сброс флага прерывания.
	//--------------------------
	//Led_PC13_Toggel();
}
//*******************************************************************************************
//*******************************************************************************************































